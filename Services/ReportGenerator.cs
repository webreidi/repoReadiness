using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using RepoReadiness.Configuration;
using RepoReadiness.Models;

namespace RepoReadiness.Services;

public static class ReportGenerator
{
    public static void GenerateReport(string repoName)
    {
        var sb = new StringBuilder();
        int totalScore = AssessmentConfig.Scores.Values.Sum();
        int bonusScore = AssessmentConfig.BonusScores.Values.Sum();
        int maxScore = CalculateMaxScore();
        int maxBonus = CalculateMaxBonus();
        string grade = CalculateGrade(totalScore, maxScore);

        sb.AppendLine($"# Repository Readiness Report: {repoName}");
        sb.AppendLine();
        sb.AppendLine($"**Assessment Date:** {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine($"**Tool Version:** 3.1");
        sb.AppendLine($"**Copilot SDK:** {(AssessmentConfig.CopilotAvailable ? "Available" : "Not available")}");
        sb.AppendLine();
        
        // Display score with bonus
        if (bonusScore > 0)
        {
            sb.AppendLine($"## Overall Score: {totalScore}/{maxScore} ({grade}) + {bonusScore} bonus");
            sb.AppendLine();
            sb.AppendLine($"- **Base Score:** {totalScore}/{maxScore} ({(double)totalScore/maxScore:P0})");
            sb.AppendLine($"- **Bonus Points:** +{bonusScore} (Custom Agents, Agent Skills)");
            sb.AppendLine($"- **Combined:** {totalScore + bonusScore}/{maxScore}");
        }
        else
        {
            sb.AppendLine($"## Overall Score: {totalScore}/{maxScore} ({grade})");
        }
        sb.AppendLine();
        sb.AppendLine(GetGradeDescription(grade));
        sb.AppendLine();

        sb.AppendLine("## Category Breakdown");
        sb.AppendLine();
        sb.AppendLine("### Base Categories");
        sb.AppendLine();
        sb.AppendLine("| Category | Score | Max |");
        sb.AppendLine("|----------|-------|-----|");

        var maxScores = GetMaxScores();
        foreach (var kvp in AssessmentConfig.Scores)
        {
            sb.AppendLine($"| {kvp.Key} | {kvp.Value} | {maxScores[kvp.Key]} |");
        }
        sb.AppendLine();

        // Bonus categories
        if (AssessmentConfig.BonusScores.Values.Any(v => v > 0))
        {
            sb.AppendLine("### Bonus Categories");
            sb.AppendLine();
            sb.AppendLine("| Category | Bonus | Max |");
            sb.AppendLine("|----------|-------|-----|");
            var maxBonusScores = GetMaxBonusScores();
            foreach (var kvp in AssessmentConfig.BonusScores)
            {
                if (kvp.Value > 0)
                    sb.AppendLine($"| {kvp.Key} | +{kvp.Value} | +{maxBonusScores[kvp.Key]} |");
            }
            sb.AppendLine();
        }

        sb.AppendLine("## Detailed Findings");

        // Base category findings
        foreach (var kvp in AssessmentConfig.Findings.Where(f => AssessmentConfig.Scores.ContainsKey(f.Key)))
        {
            AddCategorySection(sb, kvp.Key, kvp.Value);
        }

        // Bonus category findings
        foreach (var kvp in AssessmentConfig.Findings.Where(f => AssessmentConfig.BonusScores.ContainsKey(f.Key)))
        {
            AddCategorySection(sb, kvp.Key + " (Bonus)", kvp.Value);
        }

        sb.AppendLine();
        sb.AppendLine("## Priority Actions");
        sb.AppendLine();

        var allRecommendations = AssessmentConfig.Findings
            .SelectMany(f => f.Value.Recommendations.Select(r => (Category: f.Key, Recommendation: r)))
            .Take(5)
            .ToList();

        if (allRecommendations.Any())
        {
            int i = 1;
            foreach (var rec in allRecommendations)
            {
                sb.AppendLine($"{i}. **[{rec.Category}]** {rec.Recommendation}");
                i++;
            }
        }
        else
        {
            sb.AppendLine("No critical recommendations - repository is well-configured!");
        }

        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine("*Generated by Repository Readiness Assessment Tool v3.1*");

        // Save report to the tool's directory, not the assessed repo
        var toolDir = AppDomain.CurrentDomain.BaseDirectory;
        // Navigate up from bin/Debug/net10.0 to the project root
        var projectRoot = Path.GetFullPath(Path.Combine(toolDir, "..", "..", ".."));
        var reportsDir = Path.Combine(projectRoot, "readiness-reports");
        Directory.CreateDirectory(reportsDir);
        var reportPath = Path.Combine(reportsDir, $"{repoName}-readiness-report_{DateTime.Now:yyyy-MM-dd_HH-mm-ss}.md");
        File.WriteAllText(reportPath, sb.ToString());

        Console.WriteLine($"\nReport saved to: {reportPath}");
    }

    private static void AddCategorySection(StringBuilder sb, string category, CategoryFindings findings)
    {
        sb.AppendLine();
        sb.AppendLine($"### {category}");

        if (findings.Strengths.Any())
        {
            sb.AppendLine();
            sb.AppendLine("**Strengths:**");
            foreach (var s in findings.Strengths)
                sb.AppendLine($"- {s}");
        }

        if (findings.Weaknesses.Any())
        {
            sb.AppendLine();
            sb.AppendLine("**Weaknesses:**");
            foreach (var w in findings.Weaknesses)
                sb.AppendLine($"- {w}");
        }

        if (findings.Recommendations.Any())
        {
            sb.AppendLine();
            sb.AppendLine("**Recommendations:**");
            foreach (var r in findings.Recommendations)
                sb.AppendLine($"- {r}");
        }

        if (!findings.Strengths.Any() && !findings.Weaknesses.Any() && !findings.Recommendations.Any())
        {
            sb.AppendLine();
            sb.AppendLine("*No specific findings for this category.*");
        }
    }

    private static Dictionary<string, int> GetMaxScores()
    {
        return new Dictionary<string, int>
        {
            { "Build", 20 },
            { "Run", 15 },
            { "Test", 20 },
            { "CodeQuality", 30 },
            { "CodeComplexity", 25 },
            { "Documentation", 25 },
            { "CustomInstructions", 20 },
            { "TypeSafety", 10 },
            { "ContextFriendliness", 10 }
        };
    }

    private static Dictionary<string, int> GetMaxBonusScores()
    {
        return new Dictionary<string, int>
        {
            { "CustomAgents", 5 },
            { "AgentSkills", 5 }
        };
    }

    private static int CalculateMaxScore()
    {
        return GetMaxScores().Values.Sum(); // Sum of all base category max scores
    }

    private static int CalculateMaxBonus()
    {
        return GetMaxBonusScores().Values.Sum(); // 10 bonus
    }

    private static string CalculateGrade(int score, int maxScore)
    {
        double percentage = (double)score / maxScore;
        return percentage switch
        {
            >= 0.9 => "A",
            >= 0.8 => "B",
            >= 0.7 => "C",
            >= 0.6 => "D",
            _ => "F"
        };
    }

    private static string GetGradeDescription(string grade)
    {
        return grade switch
        {
            "A" => "> Excellent! This repository is highly optimized for GitHub Copilot assistance.",
            "B" => "> Good! This repository is well-prepared for Copilot with minor improvements possible.",
            "C" => "> Adequate. Some improvements needed to maximize Copilot effectiveness.",
            "D" => "> Needs Work. Several areas require attention for effective Copilot usage.",
            _ => "> Significant improvements needed before this repository can effectively use Copilot."
        };
    }

    public static void DisplaySummary()
    {
        Console.WriteLine();
        Console.WriteLine("═══════════════════════════════════════");
        Console.WriteLine("           ASSESSMENT SUMMARY          ");
        Console.WriteLine("═══════════════════════════════════════");
        Console.WriteLine();

        var maxScores = GetMaxScores();
        Console.WriteLine("Base Categories:");
        foreach (var kvp in AssessmentConfig.Scores)
        {
            int barLength = Math.Min(20, kvp.Value * 20 / maxScores[kvp.Key]);
            var bar = new string('█', barLength);
            var empty = new string('░', 20 - barLength);
            Console.WriteLine($"  {kvp.Key,-20} [{bar}{empty}] {kvp.Value,3}/{maxScores[kvp.Key]}");
        }

        // Display bonus scores if any
        int bonusTotal = AssessmentConfig.BonusScores.Values.Sum();
        if (bonusTotal > 0)
        {
            Console.WriteLine();
            Console.WriteLine("Bonus Categories:");
            var maxBonusScores = GetMaxBonusScores();
            foreach (var kvp in AssessmentConfig.BonusScores.Where(b => b.Value > 0))
            {
                int barLength = Math.Min(20, kvp.Value * 20 / maxBonusScores[kvp.Key]);
                var bar = new string('█', barLength);
                var empty = new string('░', 20 - barLength);
                Console.WriteLine($"  {kvp.Key,-20} [{bar}{empty}] +{kvp.Value,2}/{maxBonusScores[kvp.Key]}");
            }
        }

        Console.WriteLine();
        int total = AssessmentConfig.Scores.Values.Sum();
        int max = CalculateMaxScore();
        string grade = CalculateGrade(total, max);
        
        if (bonusTotal > 0)
            Console.WriteLine($"Total Score: {total}/{max} ({grade}) + {bonusTotal} bonus");
        else
            Console.WriteLine($"Total Score: {total}/{max} ({grade})");
        Console.WriteLine();
    }
}